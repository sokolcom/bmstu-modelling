\chapter{Конструкторская часть}

\section{Требования к программе}

К вводимым данным существуют следующие требования:
\begin{enumerate}
	\item на вход подается массив целых чисел, который следует отсортировать;
	\item предусмотреть генерацию случайного массива заданной длины.
\end{enumerate}


Непосредственно к программе применяются следующие требования:
\begin{enumerate}
	\item корректная сортировка массивов;
	\item если введены недопустимые данные (например, размерность массива меньше нуля), программа не должна аварийно завершаться.
\end{enumerate}




\section{Схемы алгоритмов}

Далее будут приведены схемы алгоритмов сортировки вставками (рис. 2.1) и пузырьком (рис. 2.2).
\newpage

\begin{figure}[!htbp]
\centering
\includegraphics[scale=0.6]{sch_insert}
\caption{Схема алгоритма сортировки вставками}
\label{fig:mpr}
\end{figure}

\begin{figure}[!htbp]
\centering
\includegraphics[scale=0.5]{sch_bubble}
\caption{Схема алгоритма сортировки пузырьком}
\label{fig:mpr}
\end{figure}





\section{Трудоемкость алгоритмов}

\subsection{Модель оценки трудоемкости}

Введем модель трудоемкости для оценки алгоритмов:
\begin{enumerate}
	\item  базовые операции стоимостью 1: $+, -, *, /, =, ==, <=, >=, !=, +=, []$;
	\item оценка трудоемкости цикла: $F_{cycle} = a + N*(a + F_{body})$, где a - условие цикла
	\item стоимость условного перехода будем считать равным 0;
	\item стоимость вычисления условия остаётся.
\end{enumerate}


\subsection{Алгоритм сортировки вставками}

В таблице 2.1 приведено построчная оценка трудоемкости алгоритма сортировки вставками.
\begin{table}[h!]
	\centering
	\caption{Построчная оценка трудоемкости сортировки вставками}
	\begin{tabular}{|c c|} 
		\hline
		Строчка кода & Вес \\ [0.5ex] 
		\hline
		for j in range(1, length): & 3 \\
		\hline
		i = j - 1 & 2 \\
		\hline
		while (i >= 0) and (array[i] > value): & 4 \\
		\hline
		array[i + 1] = array[i] & 4 \\
		\hline
		i -= 1 & 1 \\
		\hline
		array[i + 1] = value & 3 \\
		\hline
	\end{tabular}
\end{table}

\textbf{Лучший случай:} отсортированный массив. При этом все внутренние циклы состоят всего из одной итерации.\newline
Трудоемкость: $T(n) = 3n + ((2 + 4 + 1 + 3) * (n - 1))  =  3n + 10(n-1) = 13n - 10 = O(n)$

\textbf{Худший случай:} массив отсортирован в обратном нужному порядке. Каждый новый элемент сравнивается со всеми в отсортированной последовательности.
Все внутренние циклы будут состоять из j итераций. \newline
Трудоемкость: $T(n) = 3n + (2 + 2)(n-1) + 4 \left({\frac {n(n+1)}{2}}-1\right)+5{\frac {n(n-1)}{2}}+3(n-1) = 3n + 4n - 4 + 2n^2 + 2n - 4 + 2.5n^2 - 2.5n + 3n - 3 = 4.5n^2 + 9.5n - 11 = O(n^{2})$



\subsection{Алгоритм сортировки пузырьком}

В таблице 2.2 приведено построчная оценка трудоемкости алгоритма сортировки пузырьком.
\begin{table}[h!]
	\centering
	\caption{Построчная оценка трудоемкости сортировки пузырьком}
	\begin{tabular}{|c c|} 
		\hline
		Строчка кода & Вес \\ [0.5ex] 
		\hline
		for i in range(length - 1): & 4 \\
		\hline
		for j in range(i + 1, length): & 4 \\
		\hline
		if array[i] > array[j]: & 3 \\
		\hline
		temp = array[i] & 2 \\
		\hline
		array[i] = array[j] & 3 \\
		\hline
		array[j] = temp & 2 \\
		\hline
	\end{tabular}
\end{table}


\textbf{Лучший случай:} Массив отсортирован; не произошло ни одного обмена за 1 проход -> выходим из цикла \newline
Трудоемкость:  $n* (2 + 7 + 1 + 3 ) + 2 = 13n + 2 = O(n)$

\textbf{Худший случай:}  Массив отсортирован в обратном порядке; в каждом случае происходил обмен\newline
Трудоемкость: $n*(n* (4 + 4 + 3 + 2 + 3 + 2)) =  17n^2 = O(n^2)$



\subsection{Алгоритм быстрой сортировки}

\textbf{Лучший случай:} сбалансированное дерево вызовов \(O(n*log(n))\)  
В наиболее благоприятном случае сортировка двух подмассивов сводится к двум подзадачам, размер каждой из которых не превышает $\frac{n}{2}$, поскольку размер одной из них равен $\frac{n}{2}$ , а второй$\frac{n}{2} - 1$. В такой ситуации быстрая сортировка работает намного производительнее, и время ее работы описывается следующим рекуррентным соотношением: $T(n) = 2T(\frac{n}{2}) + O(n)$,где мы не обращаем внимания на неточность, связанную с игнорированием функций “пол” и “потолок”, и вычитанием 1. Это рекуррентное соотношение имеет решение ; $T(n) = O(nlogn)$. При сбалансированности двух частей разбиения на каждом уровне рекурсии мы получаем асимптотически более быстрый алгоритм.

Фактически любое разбиение, характеризующееся конечной константой пропорциональности, приводит к образованию дерева рекурсии высотой $O(lgn)$ со стоимостью каждого уровня, равной $O(n)$. Следовательно, при любой постоянной пропорции разбиения полное время работы быстрой сортировки составляет $O(nlogn)$.

\textbf{Худший случай:} несбалансированное дерево $O(n^2)$
Поскольку рекурсивный вызов процедуры разбиения, на вход которой подается массив размером 0, приводит к немедленному возврату из этой процедуры без выполнения каких-ли-бо операций, $T(0) = O(1)$. Таким образом, рекуррентное соотношение, описывающее время работы процедуры в указанном случае, записывается следующим образом: 
$T(n) =T(n-1) +T(0) + O(n) =T(n-1) + O(n)$. Интуитивно понятно, что при суммировании промежутков времени, затрачиваемых на каждый уровень рекурсии, получается арифметическая прогрессия, что приводит к результату $O(n^2)$. \cite{Cormen}


\section*{Вывод}
В данном разделе были рассмотрены требования для программы, схемы алгоритмов сортировки вставками и пузырьком, а также была рассчитана трудоемкость алгоритмов, на основе введенной модели.

Результаты расчетов следующие:
\begin{itemize}
	\item сортировка пузырьком: лучший - $O(n)$, худший - $O(n^2)$;
	\item сортировка вставками: лучший - $O(n)$, худший - $O(n^2)$;
	\item быстрая сортировка: лучший - $O(nlogn)$, худший - $O(n^2)$;
\end{itemize}

При этом сортировка вставками быстрее пузырька с флагом в худшем случае т.к. имеет меньший коэффициент: $4.5n^2$ и $18n^2$ соответственно.



